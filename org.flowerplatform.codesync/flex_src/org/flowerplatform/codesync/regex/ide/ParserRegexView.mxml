<?xml version="1.0" encoding="utf-8"?>
<!-- 
license-start

Copyright (C) 2008 - 2013 Crispico, <http://www.crispico.com/>.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation version 3.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details, at <http://www.gnu.org/licenses/>.

Contributors:
Crispico - Initial API and implementation  The product is licensed under GPL. This is the new version of the license.

license-end
-->
<!-- 
@author Cristina Constatinescu
-->
<s:VGroup xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" xmlns:tree="org.flowerplatform.flexutil.tree.*"
			   implements="org.flowerplatform.flexutil.view_content_host.IViewContent, org.flowerplatform.flexutil.selection.ISelectionProvider, org.flowerplatform.flexutil.selection.ISelectionForServerProvider"
			   paddingTop="5" paddingBottom="5"
			   initialize="initializeHandler(event)" >
				

	<fx:Script>
		<![CDATA[
			import com.crispico.flower.util.layout.event.ViewAddedEvent;
			
			import mx.collections.ArrayCollection;
			import mx.collections.ArrayList;
			import mx.collections.IList;
			import mx.core.FlexGlobals;
			import mx.events.FlexEvent;
			
			import org.flowerplatform.codesync.CodeSyncPlugin;
			import org.flowerplatform.codesync.regex.ide.action.AddParserRegexAction;
			import org.flowerplatform.codesync.regex.ide.action.RemoveParserRegexAction;
			import org.flowerplatform.codesync.regex.ide.remote.RegexMatchDto;
			import org.flowerplatform.codesync.regex.ide.remote.RegexSelectedItem;
			import org.flowerplatform.codesync.regex.ide.ui.ParserRegexHierachicalModelAdapter;
			import org.flowerplatform.communication.CommunicationPlugin;
			import org.flowerplatform.communication.service.InvokeServiceMethodServerCommand;
			import org.flowerplatform.emf_model.regex.MacroRegex;
			import org.flowerplatform.emf_model.regex.ParserRegex;
			import org.flowerplatform.flexutil.FlexUtilGlobals;
			import org.flowerplatform.flexutil.action.IAction;
			import org.flowerplatform.flexutil.layout.event.ViewRemovedEvent;
			import org.flowerplatform.flexutil.tree.HierarchicalModelWrapper;
			import org.flowerplatform.flexutil.view_content_host.IViewHost;
			
			import spark.events.IndexChangeEvent;
			
			protected var _viewHost:IViewHost;
			
			public function getActions(selection:IList):Vector.<IAction> {			
				var result:Vector.<IAction> = new Vector.<IAction>();
				result.push(new AddParserRegexAction());		
				result.push(new RemoveParserRegexAction(this));
				return result;
			}
			
			public function set viewHost(viewHost:IViewHost):void {
				if (_viewHost != null) {
					DisplayObject(_viewHost).removeEventListener(ViewAddedEvent.VIEW_ADDED, viewAddedHandler);
					DisplayObject(_viewHost).removeEventListener(ViewRemovedEvent.VIEW_REMOVED, viewRemovedHandler);	
				}
				
				_viewHost = viewHost;
				
				DisplayObject(_viewHost).addEventListener(ViewAddedEvent.VIEW_ADDED, viewAddedHandler);
				DisplayObject(_viewHost).addEventListener(ViewRemovedEvent.VIEW_REMOVED, viewRemovedHandler);	
			}
			
			public function itemLabelFunction(data:HierarchicalModelWrapper):String {
				if (data.treeNode is RegexMatchDto) {
					return "Match " + RegexMatchDto(data.treeNode).value;
				} 
				return ParserRegex(data.treeNode).name;
			}
			
			public function itemIconFunction(data:HierarchicalModelWrapper):Object {
				if (data.treeNode is RegexMatchDto) {
					return CodeSyncPlugin.getInstance().getResourceUrl("images/regex/brick.png");
				} 
				return CodeSyncPlugin.getInstance().getResourceUrl("images/regex/bricks.png");
			}
			
			protected function initializeHandler(event:FlexEvent):void {
				addEventListener(ViewAddedEvent.VIEW_ADDED, viewAddedHandler);
				addEventListener(ViewRemovedEvent.VIEW_REMOVED, viewRemovedHandler);
							
				tree.rootNode = new ParserRegex();
			}
			
			private function viewAddedHandler(event:ViewAddedEvent):void {
				// show actions in buttonBar
				_viewHost.selectionChanged();
				
				FlexGlobals.topLevelApplication.addEventListener(RegexDataEvent.SELECTED_CONFIG_CHANGED, selectedConfigChangedHandler);
				FlexGlobals.topLevelApplication.addEventListener(RegexDataEvent.PARSERS_REQUEST_REFRESH, refreshHandler);
//				FlexGlobals.topLevelApplication.addEventListener(RegexDataEvent.REGEX_ACTIONS_CHANGED, regexActionsChangedHandler);
				FlexGlobals.topLevelApplication.addEventListener(RegexDataEvent.REGEX_MATCHES_SELECTED_CHANGED, regexMatchesSelectedChangedHandler);
			}
			
			private function viewRemovedHandler(event:ViewRemovedEvent):void {
				
				FlexGlobals.topLevelApplication.removeEventListener(RegexDataEvent.SELECTED_CONFIG_CHANGED, selectedConfigChangedHandler);
				FlexGlobals.topLevelApplication.removeEventListener(RegexDataEvent.PARSERS_REQUEST_REFRESH, refreshHandler);
//				FlexGlobals.topLevelApplication.removeEventListener(RegexDataEvent.REGEX_ACTIONS_CHANGED, regexActionsChangedHandler);
				FlexGlobals.topLevelApplication.removeEventListener(RegexDataEvent.REGEX_MATCHES_SELECTED_CHANGED, regexMatchesSelectedChangedHandler);
			}
			
//			private function regexActionsChangedHandler(event:RegexDataEvent):void {				
//				ParserRegex(tree.rootNode).matches = event.newData;
//				tree.refreshLinearizedDataProvider();
//			}
			
			protected function changeHandler(e:IndexChangeEvent):void {				
				var array:Array = [];
				var event:RegexDataEvent = new RegexDataEvent(RegexDataEvent.REGEX_ACTIONS_SELECTED_CHANGED);
				for each (var selected:Object in tree.selectedItems) {
					var item:Object = HierarchicalModelWrapper(selected).treeNode;
					if (item is ParserRegex) {
						if (ParserRegex(item).matches.length == 0) {
							continue;
						}
						for (var i:int = 0; i < ParserRegex(item).matches.length; i++) {
							var match:RegexMatchDto = RegexMatchDto(ParserRegex(item).matches.getItemAt(i));
							if (array.indexOf(match) == -1) {
								array.push(match);
							}
						}					
					} else {
						array.push(item);
					}					
				}
				event.newSelectedMatches = array;
				FlexGlobals.topLevelApplication.dispatchEvent(event);
				
				FlexUtilGlobals.getInstance().selectionManager.selectionChanged(_viewHost, this);				
			}
			
			private function regexMatchesSelectedChangedHandler(event:RegexDataEvent):void {		
				var vector:Vector.<int> = new Vector.<int>();
				for each (var match:RegexMatchDto in event.newSelectedMatches) {
					var item:HierarchicalModelWrapper = findRegexItem(match.parserRegex.name);
					if (item != null) {
						if (!item.expanded) {
							item.expanded = true;
							tree.refreshLinearizedDataProvider();
						}
						var index:int = findRegexMatchItemIndex(match.value);
						if (index != -1) {
							vector.push(index);
						}
					}
				}
				tree.refreshLinearizedDataProvider();
				tree.selectedIndices = vector;		
				if (tree.selectedIndices.length > 0) {
					tree.ensureIndexIsVisible(tree.selectedIndices[0]);
				}
			}
			
			private function findRegexItem(name:String):HierarchicalModelWrapper {
				for (var i:int = 0; i < tree.dataProvider.length; i++) {
					var item:HierarchicalModelWrapper = HierarchicalModelWrapper(tree.dataProvider.getItemAt(i));
					if (item.treeNode is ParserRegex && ParserRegex(item.treeNode).name == name) {
						return item;
					}
				}
				return null;
			}
			
			private function findRegexMatchItemIndex(value:String):int {
				for (var i:int = 0; i < tree.dataProvider.length; i++) {
					var item:HierarchicalModelWrapper = HierarchicalModelWrapper(tree.dataProvider.getItemAt(i));
					if (item.treeNode is RegexMatchDto && RegexMatchDto(item.treeNode).value == value) {
						return i;
					}
				}
				return -1;
			}
			
			public function getSelection():IList {			
				var array:ArrayList = new ArrayList();
				for (var i:int = 0; i < tree.selectedItems.length; i++) {
					array.addItem(tree.selectedItems[i]);
				}
				return array;
			}
			
			public function convertSelectionToSelectionForServer(selection:IList):IList {
				if (selection == null) {
					return selection;
				}			
				var selectedItems:ArrayCollection = new ArrayCollection();
				for each (var selected:Object in selection.toArray()) {
					var selectedItem:RegexSelectedItem = new RegexSelectedItem();
					var item:Object = HierarchicalModelWrapper(selected).treeNode;
					if (item is ParserRegex) {										
						selectedItem.regex = MacroRegex(item);
						selectedItem.config = CodeSyncPlugin.getInstance().regexUtils.selectedConfig;
						selectedItem.itemType = "regex_parser";						
					} else {
						selectedItem.match = RegexMatchDto(item);
						selectedItem.itemType = "regex_match";		
					}
					selectedItems.addItem(selectedItem);
				}				
				return selectedItems;
			}
			
			private function selectedConfigChangedHandler(event:RegexDataEvent):void {
				if (CodeSyncPlugin.getInstance().regexUtils.selectedConfig == null) {
					tree.dataProvider.removeAll();
				} else {
					refreshHandler();
				}
			}
			
			public function refreshHandler(event:RegexDataEvent = null):void {
				CommunicationPlugin.getInstance().bridge.sendObject(
					new InvokeServiceMethodServerCommand("regexService", "getParserRegexes", [CodeSyncPlugin.getInstance().regexUtils.selectedConfig], 
						this, getParserRegexesCallbackHandler));
			}
			
			public function getParserRegexesCallbackHandler(result:ArrayCollection):void {				
				ParserRegex(tree.rootNode).matches = result;
				tree.refreshLinearizedDataProvider();
			}
		]]>
	</fx:Script>
	
	<s:Label text="{CodeSyncPlugin.getInstance().regexUtils.selectedConfig != null ? CodeSyncPlugin.getInstance().getMessage('regex.selectedConfig', [CodeSyncPlugin.getInstance().regexUtils.selectedConfig]) : CodeSyncPlugin.getInstance().getMessage('regex.selectedConfig.none')}" 
			 width="100%" paddingLeft="5" fontWeight="bold" />
	
	<tree:TreeList id="tree" hierarchicalModelAdapter="{new ParserRegexHierachicalModelAdapter()}"
				   change="changeHandler(event)" allowMultipleSelection="true" width="100%" height="100%">
		<tree:itemRenderer>
			<fx:Component>
				<tree:TreeListItemRenderer labelFunction="{outerDocument.itemLabelFunction}" iconFunction="{outerDocument.itemIconFunction}"/>
			</fx:Component>
		</tree:itemRenderer>	
	</tree:TreeList>
</s:VGroup>